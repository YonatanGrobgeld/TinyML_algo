## Project Overview

This repository contains TinyML algorithms and kernels with a focus on deployment on FPGA, RISC-V, and LiteX-based systems. The code is derived from and extends the original PULP transformer kernels to support additional platforms and microcontroller-style execution environments.

## TinyFormer on VexRiscv + LiteX (FPGA)

A TinyFormer encoder block (Transformer-style TinyML model) is implemented for a bare-metal RV32IM core running on VexRiscv generated by LiteX, targeted at FPGA platforms such as the Nexys 4 DDR.

The implementation under `litex_port/` is designed to:

- **Target**: bare-metal RV32IM (no OS, no threads) on VexRiscv generated by LiteX.
- **Platform**: tested/targeted for Nexys 4 DDR FPGA (LiteX SoC).
- **Portability**: use only standard integer types and fixed-size buffers so it can be reused on other RV32-class MCUs and SoCs.

---

## FPGA Bring-Up & Benchmarking (Nexys4DDR + LiteX + VexRiscv) — Teammate Checklist

Step-by-step playbook for the teammate who owns the FPGA / LiteX / VexRiscv side. Use this order; do not benchmark until correctness matches baseline.

### A. Prerequisites (what exists where)

- **This repo provides:** TinyFormer firmware sources (`litex_port/common/`, mode dirs), accelerator drivers (`hw_extensions/dot8/sw/`, `hw_extensions/exp_lut/sw/`, `hw_extensions/gemv/sw/`), self-tests (`litex_port/tests_dot8.c/h`, `tests_lut.c/h`, `tests_gemv.c/h`), and mode mains (baseline + 5 accelerated).
- **This repo does NOT provide:** LiteX SoC target build scripts, bitstream build, linker script, crt0, generated CSR headers, or SoC memory map — those live in your LiteX build tree.
- **Hardware assumptions:** VexRiscv RV32IM; UART present in SoC as `uart` or `serial`; SDRAM/main RAM usable for firmware (memtest must pass).

### B. Known-good bring-up order (must be explicit)

1. **Fix LiteX memory init first** — Memtest must pass. Resolve any SDRAM/MAIN-RAM init or timing issues before running TinyFormer firmware.
2. **Build and run baseline firmware** — Use `litex_port/common/*` + `litex_port/baseline/main_baseline.c`. Confirm UART shows `MODE: BASELINE`, then `ENC_CKSUM=0x...` and `Sample i: pred=X exp=Y` for each sample. Save this log as the correctness reference.
3. **Run self-tests** — In this order: **LUT** → **GEMV** → **DOT8**. Each test prints a PASS line on UART. See §10 and “Tests” in D below for sources and drivers to link.
4. **Build accelerated modes one-by-one** — Add the right drivers and macros per mode (see D and E). For each mode, run and verify **correctness vs baseline** (same `ENC_CKSUM` and same `pred`/`exp` per sample).
5. **Only then measure performance** — After all accelerated builds match baseline checksums and predictions, use cycle counter or timer (see G) to compare baseline vs each accel mode.

### C. Where to find LiteX generated headers and how to include them

- **Path:** Your LiteX build produces `<litex_build>/software/include`; CSR and peripheral accessors are in `generated/csr.h` under that include directory.
- **Compile firmware with:**  
  `-I<litex_build>/software/include`  
  so that `#include <generated/csr.h>` resolves. Example (replace with your path):  
  `-I/path/to/litex/build/nexys4ddr/software/include`
- **UART selection:** `uart_litex.c` picks the implementation at compile time: if `CSR_UART_RXTX_ADDR` is defined (from `generated/csr.h`), it uses `uart_*`; else if `CSR_SERIAL_RXTX_ADDR` is defined, it uses `serial_*`. No code change needed — just ensure the correct macro is defined by your LiteX SoC.

### D. What to compile/link (concise and exact)

**Common to all demo builds:** From `litex_port/common/`: `tinyformer.c`, `demo_samples.c`, `demo_classifier.c`, `demo_runner.c`, `uart_litex.c`, `trained_weights.c`. Always link UART (`uart_litex.c`) for banner and `ENC_CKSUM` output.

| Build | Main | Extra driver sources |
|-------|------|----------------------|
| **Baseline** | `litex_port/baseline/main_baseline.c` | none |
| **DOT8 only** | `litex_port/accel_dot8/main_dot8.c` | `hw_extensions/dot8/sw/dot8.c` |
| **LUT only** | `litex_port/accel_lut/main_lut.c` | `hw_extensions/exp_lut/sw/exp_lut.c` |
| **GEMV only** | `litex_port/accel_gemv/main_gemv.c` | `hw_extensions/gemv/sw/gemv.c` |
| **DOT8 + LUT** | `litex_port/accel_dot8_lut/main_dot8_lut.c` | `dot8.c` + `exp_lut.c` |
| **All** | `litex_port/accel_all/main_all.c` | `dot8.c` + `exp_lut.c` + `gemv.c` |

**Self-tests** (separate firmware or called from a test main):

- **test_dot8:** `litex_port/tests_dot8.c`, `tests_dot8.h`, `hw_extensions/dot8/sw/dot8.c`, `uart_litex.c`. Include: `-I litex_port -I hw_extensions/dot8/sw` (and LiteX include path).
- **test_lut:** `litex_port/tests_lut.c`, `tests_lut.h`, `hw_extensions/exp_lut/sw/exp_lut.c`, `uart_litex.c`. Include: `-I litex_port -I hw_extensions/exp_lut/sw`.
- **test_gemv:** `litex_port/tests_gemv.c`, `tests_gemv.h`, `hw_extensions/gemv/sw/gemv.c`, `uart_litex.c`. Include: `-I litex_port -I hw_extensions/gemv/sw`.

### E. Build flags (important ones)

- **Common (all builds):**  
  `-ffreestanding -nostdlib -march=rv32im -mabi=ilp32 -O2` (or `-O3`)
- **Demo / weights:**  
  `-DUSE_TRAINED_WEIGHTS=1`
- **UART:**  
  `-DUSE_LITEX_UART`
- **LiteX headers:**  
  `-I<litex_build>/software/include`
- **DOT8 (only if Dot8Plugin is in the CPU build):**  
  `-DUSE_DOT8_HW -I hw_extensions/dot8/sw`
- **LUT:**  
  `-DUSE_EXP_LUT_HW` and either `-DEXP_LUT_USE_LITEX_CSR` (with generated CSR) or `-DEXP_LUT_BASE=<addr>`. Include: `-I hw_extensions/exp_lut/sw`
- **GEMV:**  
  `-DUSE_GEMV_HW` and either `-DGEMV_USE_LITEX_CSR` or `-DGEMV_BASE=<addr>`. Include: `-I hw_extensions/gemv/sw`

### F. Correctness gate (must be very explicit)

For **each sample** in each accelerated run, verify:

1. **`MODE: ...`** banner matches the build (e.g. `MODE: DOT8`, `MODE: DOT8 + LUT + GEMV`).
2. **`ENC_CKSUM=0xXXXXXXXX`** is **identical** to the baseline run for that same sample index. If it differs, the accelerated path is wrong — **do not benchmark**; stop and debug.
3. **`pred` / `exp`** match the baseline (same predicted and expected class per sample).

Do **not** record or compare performance until every accelerated build passes this gate.

### G. Performance measurement hooks (guidance only; don’t implement here)

- Use a **LiteX timer/cycle counter** if your SoC exposes one (e.g. CSR timer), or read **RISC-V `mcycle`** (if the core exposes it) before and after `tinyformer_encode()` (or before/after the full demo loop).
- **Order:** Run baseline once and record cycles per sample (or per encoder call); then run each accelerated mode and record the same. Compare cycles to see speedup.
- This repo does not add cycle-count code; you add it in your main or in a thin wrapper around `demo_run()` / `tinyformer_encode()`.

### H. Troubleshooting (short table)

| Symptom | Likely cause / action |
|--------|------------------------|
| **No UART output** | Wrong UART name in SoC (check `CSR_UART_RXTX_ADDR` vs `CSR_SERIAL_RXTX_ADDR`); missing `-I<litex_build>/software/include`; or `-DUSE_LITEX_UART` not set. |
| **Illegal instruction** | `USE_DOT8_HW` defined but VexRiscv built without Dot8Plugin → disable `-DUSE_DOT8_HW` or add plugin and rebuild SoC. |
| **LUT returns wrong values** | CSR mapping / wrong base / index width; confirm exp_lut RTL and `generated/csr.h` match; check index 0..15 and Q10 output. |
| **GEMV mismatch** | CSR strobes (START / CLEAR_DONE); Y read pointer advance (`Y_NEXT` write); endian or dimension (32 vs 64) mismatch. |
| **ENC_CKSUM differs from baseline** | Accelerated math not identical to C path — stop benchmarking and fix encoder/accelerator path (scaling, saturation, or driver use). |

---

## TinyFormer Encoder Algorithm

The TinyFormer encoder block implemented here follows the standard Transformer encoder structure, specialized for int8 inference and streaming attention:

- **Q/K/V linear projections**:  
  Input tokens `X` with shape \(S \times D\) (sequence length \(S = 16\), model dimension \(D = 32\)) are projected to queries, keys, and values using int8 weight matrices and int32 accumulators.

- **Streaming (tiled) scaled dot-product attention**:  
  For each query position, dot products with all keys are accumulated in int32, scaled, and then converted to attention scores. The implementation **does not** allocate an explicit \(S \times S\) attention matrix; instead it processes one query at a time and reuses 1D scratch buffers.

- **Max-subtraction softmax with small LUT**:  
  For numerical stability, the maximum score for each query is subtracted before a fixed-point softmax. A small integer lookup table approximates \(\exp(x)\) over a limited range, and the resulting values are normalized using a Q15-style fixed-point representation.

- **Context computation**:  
  The attention output for each token is obtained as a weighted sum of the value vectors using the normalized softmax weights.

- **Output projection**:  
  The attention context is passed through a final linear projection (int8 weights, int32 accumulators, saturated back to int8).

- **Residual connections**:  
  A residual connection is applied around the attention block (`Y = X + AttnOut`) and around the feed-forward network (`Z = Y + FFNOut`), with results saturated back to int8.

- **Feed-Forward Network (ReLU)**:  
  A two-layer position-wise feed-forward network with ReLU activation in the hidden layer:
  - First layer: \(D \rightarrow \text{FFN}\) (here \(\text{FFN} = 64\))
  - Second layer: \(\text{FFN} \rightarrow D\)
  Both layers use int8 weights with int32 accumulators and shift/saturate back to int8.

- **Quantization**:  
  All weights and activations are int8, with int32 accumulators and simple right-shift scaling. The current implementation uses placeholder all-zero weights which can be replaced by trained, quantized parameters.

## Memory & System Constraints

The TinyFormer implementation is designed for constrained, microcontroller-class environments:

- **Bare-metal**: no operating system, no threads, no dynamic loading.
- **No dynamic allocation**: there is no `malloc` or `free`; all buffers are statically allocated with fixed sizes.
- **Fixed-size buffers only**: sequence length \(S = 16\), model dimension \(D = 32\), and feed-forward width \(\text{FFN} = 64\) are compile-time constants.
- **Microcontroller-class SRAM usage**: global working buffers and I/O tensors require only a few kilobytes of RAM, making the kernel suitable for small RV32IM MCUs and soft cores on FPGA.
- **Hardware-acceleration friendly**: the math kernels are written in portable C, with clear matmul and attention loops that can be offloaded or accelerated in FPGA logic at a later stage.

## Directory Structure

At the top level:

- **`pulp-transformer/`** – Original PULP transformer kernels, tests, and documentation.
- **`litex_port/`** – TinyFormer firmware for VexRiscv + LiteX (FPGA bring-up and benchmarking).
- **`hw_extensions/`** – Accelerator RTL and SW: `dot8/`, `exp_lut/`, `gemv/` (each with `sw/` drivers and, where applicable, `litex/` or RTL).

**`litex_port/` layout (use this for bring-up):**

- **`litex_port/common/`** – Shared sources for **all** builds: `tinyformer.c/h`, `demo_samples.c/h`, `demo_classifier.c/h`, `demo_runner.c/h`, `uart_litex.c/h`, `trained_weights.c/h`. No duplication of TinyFormer logic; always compile these for demo and mode mains.
- **Six mode directories** (each with `main_*.c` + `README.md`):
  - **`baseline/`** – No accelerators; correctness reference.
  - **`accel_dot8/`**, **`accel_lut/`**, **`accel_gemv/`**, **`accel_dot8_lut/`**, **`accel_all/`** – Hardware-accelerated variants; same demo flow, different macros (see §11).
- **Self-tests (in `litex_port/` root):** `tests_dot8.c/h`, `tests_lut.c/h`, `tests_gemv.c/h` — link with the corresponding driver (`dot8.c`, `exp_lut.c`, `gemv.c`) and UART; see §10 and playbook D.

Legacy/original files also in `litex_port/` root: `tinyformer.h/c`, `main.c`, `demo_main.c`, `uart_litex.c/h`, `trained_weights.c/h`, `demo_samples.c/h`, `demo_classifier.c/h` (duplicated in `common/` for the new layout).

TinyFormer encoder (`tinyformer.c`): Q/K/V projections; streaming scaled dot-product attention with max-subtraction softmax and LUT; output projection and residual; feed-forward (ReLU) and final residual; int8 weights/activations, int32 accumulators.

## How to Run on LiteX

1. **Integrate sources into your LiteX firmware build**  
   Add the following files to your LiteX firmware or standalone bare-metal build:
   - `litex_port/tinyformer.c`
   - `litex_port/tinyformer.h`
   - `litex_port/main.c`

2. **Wire UART stubs to LiteX UART MMIO**  
   In `litex_port/main.c`, the function:
   - `uart_write_char(char c)`  
   is currently a stub and must be implemented using your LiteX UART registers (e.g. `UART_RXTX` and `UART_TXFULL`). `uart_write_string` and `uart_write_hex32` are built on top of `uart_write_char` and will work once this function is wired.

3. **Build as a LiteX bare-metal kernel/firmware**  
   Use your existing LiteX build flow to compile the firmware for VexRiscv (RV32IM). The result should be an ELF file, for example:
   - `firmware.elf`

4. **Load and run with `litex_term`**  
   With the FPGA bitstream and LiteX SoC loaded onto the Nexys 4 DDR:

   ```bash
   litex_term --kernel firmware.elf
   ```

   The TinyFormer test harness will run on reset, execute a single encoder block, and print a checksum line on the LiteX UART console similar to:

   ```text
   TinyFormer checksum: 0xXXXXXXXX
   ```

   This checksum can be compared against a host-side reference implementation to verify correctness.

## FPGA / LiteX Integration Guide (for firmware & SoC side)

This section is for the developer who owns the LiteX SoC build, bitstream, and firmware build system. It specifies exactly what is required to run this repo’s code on hardware.

### 1. High-level architecture

- **This repo provides**: algorithm and demo firmware source only (freestanding C under `litex_port/`). No SoC RTL, no bitstream, no firmware build system.
- **External to this repo**: LiteX SoC target (e.g. `nexys4ddr.py`), memory map, firmware Makefile, linker script, startup/crt0, and UART MMIO wiring.
- **Target**: Nexys4DDR + VexRiscv (RV32IM), bare-metal (no OS).

### 2. Required LiteX SoC assumptions

- **CPU**: VexRiscv, RV32IM.
- **Runtime**: bare-metal; no OS, no threads.
- **UART**: one UART peripheral must be enabled in the SoC, exposed in the generated CSR headers either as `uart` or as `serial`.
- **RAM**: the region used for `.text`, `.rodata`, `.data`, and `.bss` (BRAM or DDR, depending on your LiteX config) must match the firmware linker script.

### 3. Firmware build requirements

Use these compiler flags when building the firmware that includes `litex_port/`:

| Flag | Purpose |
|------|--------|
| `-ffreestanding` | Freestanding environment; no reliance on hosted libc startup. |
| `-nostdlib` | Do not link libc; you provide startup and any stubs. |
| `-march=rv32im` | Match VexRiscv ISA (or your exact variant). |
| `-mabi=ilp32` | 32-bit ABI. |
| `-O2` or `-O3` | Optimize for size/speed. |
| `-DUSE_LITEX_UART` | Enable real UART in `uart_litex.c`; omit and UART is a no-op stub. |
| `-DUSE_TRAINED_WEIGHTS=1` | Required for the UCI HAR demo so `tinyformer.c` uses `trained_weights.c`. |

### 4. Include paths

- Add the LiteX build’s software include directory so that `<generated/csr.h>` resolves, e.g.:
  - `-I<litex_build>/software/include`
- Typical layout: `<litex_build>/software/include/generated/csr.h`. The exact path depends on your LiteX target output.

### 5. Files to compile and link

Compile and link these **C sources** (headers are pulled in via `#include`):

- `litex_port/tinyformer.c`
- `litex_port/trained_weights.c`
- `litex_port/demo_samples.c`
- `litex_port/demo_classifier.c`
- `litex_port/demo_main.c` (UCI HAR demo) **or** `litex_port/main.c` (checksum demo)
- `litex_port/uart_litex.c`

Ensure the compiler can find headers in `litex_port/` (e.g. `-I<path_to_repo>/litex_port` or add `litex_port` to your include path).

### 6. UART behavior

- **Mode**: blocking, polling only. No interrupts, no `printf`, no libc.
- **Implementation**: `litex_port/uart_litex.c` selects the implementation at compile time using LiteX-generated CSR address macros:
  - If `CSR_UART_RXTX_ADDR` is defined: uses `uart_txfull_read()` and `uart_rxtx_write()`.
  - Else if `CSR_SERIAL_RXTX_ADDR` is defined: uses `serial_txfull_read()` and `serial_rxtx_write()`.
  - If neither is defined (or `USE_LITEX_UART` is not set): compiles as a stub; no characters are sent.
- **API**: the rest of the firmware calls `uart_write_char(char c)` only; `uart_write_string` and numeric printers in `main.c` / `demo_main.c` are built on top of it.

### 7. What this repo does not provide

- No LiteX SoC target (`.py`) or build scripts for the SoC.
- No firmware Makefile, linker script (`.ld`), or startup/crt0.
- No libc, newlib, or syscall stubs.
- No assumptions about caches, MMU, or optional RISC-V extensions beyond what the code uses (RV32IM).

You must supply the SoC, memory map, linker script, and startup code on the FPGA/LiteX side.

### 8. Quick bring-up checklist

- [ ] LiteX SoC builds and produces a bitstream and `generated/csr.h` (or equivalent).
- [ ] Firmware build compiles all `litex_port/` sources above and links with your startup and linker script.
- [ ] `-DUSE_LITEX_UART` and LiteX include path are set so UART is not the stub.
- [ ] UART prints characters (e.g. checksum or demo text on the serial console).
- [ ] For UCI HAR demo: `-DUSE_TRAINED_WEIGHTS=1`, and running the firmware shows lines like `pred=X exp=Y`.

### 9. Common failure modes

| Symptom | Likely cause |
|--------|----------------|
| No UART output | `-DUSE_LITEX_UART` not defined, or LiteX include path missing → `uart_litex.c` compiles as stub. |
| Missing `csr.h` or CSR macros | Wrong or missing `-I<litex_build>/software/include`; build the LiteX SoC first and point to its `software/include`. |
| UART still stub with LiteX | SoC may expose UART as `serial`; ensure `generated/csr.h` defines either `CSR_UART_RXTX_ADDR` or `CSR_SERIAL_RXTX_ADDR`. |
| Link errors (e.g. `printf`, `malloc`) | Linking against libc by mistake; use `-nostdlib` and ensure no libc objects are linked. |
| Crash or garbage output | Stack too small, or linker script places sections in wrong RAM region; align script with SoC memory map (BRAM/DDR). |

### 10. Hardware extension self-tests (DOT8, Exp LUT, GEMV)

Before integrating hardware accelerators into TinyFormer benchmarking, run the on-target self-tests to catch signedness, packing, and CSR issues.

**DOT8** (`test_dot8`):

- **Sources:** `litex_port/tests_dot8.c`, `litex_port/tests_dot8.h`, `hw_extensions/dot8/sw/dot8.c`, `hw_extensions/dot8/sw/dot8.h`. Link with UART (e.g. `uart_litex.c`).
- **Include path:** `-I hw_extensions/dot8/sw` so `#include "dot8.h"` resolves.
- **Optional:** Define `-DUSE_DOT8_HW` when the VexRiscv DOT8 custom instruction (custom-0, funct7=0x01) is present; otherwise the test runs with software fallback (SW vs SW) and still passes.
- **PASS:** UART prints `DOT8 PASS`. **Typical failures:** wrong byte/lane order (packing), unsigned instead of signed lanes, or instruction encoding (opcode/funct7) mismatch between plugin and inline asm.

**Exp LUT** (`test_lut`):

- **Sources:** `litex_port/tests_lut.c`, `litex_port/tests_lut.h`, `hw_extensions/exp_lut/sw/exp_lut.c`, `hw_extensions/exp_lut/sw/exp_lut.h`. Link with UART.
- **Include path:** `-I hw_extensions/exp_lut/sw`.
- **Optional:** Define `-DUSE_EXP_LUT_HW` and either `-DEXP_LUT_USE_LITEX_CSR` (with generated CSR) or `-DEXP_LUT_BASE=<addr>` for raw MMIO. Without HW, the test uses the software golden table and passes.
- **PASS:** UART prints `LUT PASS`. **Typical failures:** index not 0..15, output not Q10 (values don’t match `tinyformer.c` exp_lut[]), or CSR strobe/read behavior (e.g. wrong register for value read).

**GEMV** (`test_gemv`):

- See `hw_extensions/gemv/README.md` and `litex_port/tests_gemv.c`. Build with `gemv.c`, UART, and `-DUSE_LITEX_UART` / GEMV backend as needed. **PASS:** `GEMV self-test PASS`.

**How to run:** From your firmware `main()`, call `test_dot8()`, `test_lut()`, and/or `test_gemv()`; non-zero return = fail. Use `litex_term` to see UART output. All tests are freestanding (no printf, malloc, or libc).

### 11. Baseline vs Hardware-Accelerated Builds

The `litex_port/` tree is organized so a teammate with the FPGA can run **baseline** TinyFormer (no extensions) and up to **five accelerated variants** (DOT8 only, LUT only, GEMV only, DOT8+LUT, or all three), then compare correctness and performance.

#### Modes and enabled hardware

| Mode            | Directory         | DOT8 | LUT | GEMV | Macros |
|-----------------|-------------------|------|-----|------|--------|
| Baseline        | `litex_port/baseline/`       | off | off | off | *(none)* |
| DOT8 only       | `litex_port/accel_dot8/`     | on  | off | off | `USE_DOT8_HW` |
| LUT only        | `litex_port/accel_lut/`      | off | on  | off | `USE_EXP_LUT_HW` |
| GEMV only       | `litex_port/accel_gemv/`     | off | off | on  | `USE_GEMV_HW` |
| DOT8 + LUT      | `litex_port/accel_dot8_lut/`  | on  | on  | off | `USE_DOT8_HW`, `USE_EXP_LUT_HW` |
| DOT8 + LUT + GEMV | `litex_port/accel_all/`     | on  | on  | on  | all three |

#### Feature macros

- **`USE_DOT8_HW`** — When defined: use DOT8 custom instruction (VexRiscv plugin) for int8 dot-products. When undefined: pure C path; no custom instruction.
- **`USE_EXP_LUT_HW`** — When defined: use Exp LUT peripheral for softmax. When undefined: use in-code LUT in `tinyformer.c`; no MMIO.
- **`USE_GEMV_HW`** — When defined: use GEMV peripheral for matrix-vector ops. When undefined: pure C matvec; no GEMV MMIO.

**Rule:** When a flag is **not** defined, the corresponding hardware must not be used (no illegal instruction, no MMIO access to that block).

#### SoC requirements

- **Baseline:** Plain VexRiscv (RV32IM); no DOT8 plugin, no Exp LUT, no GEMV. Always runs on an unmodified core.
- **Accelerated modes:** The SoC must include the corresponding blocks:
  - DOT8 → VexRiscv built with Dot8Plugin.
  - LUT → LiteX `exp_lut` peripheral and CSR.
  - GEMV → LiteX GEMV peripheral and CSR (or documented base address).

#### Expected behavior

- **Baseline** always works on plain VexRiscv and is the **correctness reference**. Accelerated builds must produce the same `pred=X exp=Y` outputs as baseline (for the same demo samples and weights) before any performance comparison.
- **Accelerated** builds require the matching hardware; running an accelerated firmware on an SoC that does not have that block can cause illegal instruction or bus faults.
- **Correctness checksum:** For each sample the demo prints `ENC_CKSUM=0xXXXXXXXX` (32-bit checksum over the encoder output `[16][32]`). This value must be identical across baseline and all accelerated modes for the same sample; if it differs, the accelerated path is not correct before benchmarking.

#### Build examples (CFLAGS)

Use `litex_port/common/` for shared sources and the chosen `main_*.c` from the mode directory. All builds need `-I litex_port/common` and typically `-DUSE_TRAINED_WEIGHTS=1` and `-DUSE_LITEX_UART` for the demo.

```bash
# Baseline (no accelerator macros)
CFLAGS += -I litex_port/common
# Compile: common/*.c + baseline/main_baseline.c

# DOT8 only
CFLAGS += -DUSE_DOT8_HW -I litex_port/common -I hw_extensions/dot8/sw
# + link hw_extensions/dot8/sw/dot8.c, compile accel_dot8/main_dot8.c

# LUT only
CFLAGS += -DUSE_EXP_LUT_HW -I litex_port/common -I hw_extensions/exp_lut/sw
# + link exp_lut driver, compile accel_lut/main_lut.c

# GEMV only
CFLAGS += -DUSE_GEMV_HW -I litex_port/common -I hw_extensions/gemv/sw
# + link hw_extensions/gemv/sw/gemv.c, compile accel_gemv/main_gemv.c

# DOT8 + LUT
CFLAGS += -DUSE_DOT8_HW -DUSE_EXP_LUT_HW -I litex_port/common -I hw_extensions/dot8/sw -I hw_extensions/exp_lut/sw
# + link dot8 and exp_lut, compile accel_dot8_lut/main_dot8_lut.c

# DOT8 + LUT + GEMV (all)
CFLAGS += -DUSE_DOT8_HW -DUSE_EXP_LUT_HW -DUSE_GEMV_HW -I litex_port/common \
  -I hw_extensions/dot8/sw -I hw_extensions/exp_lut/sw -I hw_extensions/gemv/sw
# + link all three drivers, compile accel_all/main_all.c
```

#### Files to compile/link per mode

All modes use **common** sources from `litex_port/common/`: `tinyformer.c`, `demo_samples.c`, `demo_classifier.c`, `demo_runner.c`, `uart_litex.c`, `trained_weights.c`. Headers as needed; include path `-I litex_port/common`. **UART:** always compile and link `litex_port/common/uart_litex.c` so banner and demo output (including `ENC_CKSUM=`) are printed.

- **Baseline**  
  - Compile/link: `litex_port/common/*.c` (all of the above), `litex_port/baseline/main_baseline.c`.  
  - No accelerator drivers.

- **DOT8 only**  
  - Compile/link: same common sources + `litex_port/accel_dot8/main_dot8.c`, **`hw_extensions/dot8/sw/dot8.c`** (DOT8 driver).  
  - Include: `-I litex_port/common -I hw_extensions/dot8/sw`.

- **LUT only**  
  - Compile/link: same common sources + `litex_port/accel_lut/main_lut.c`, **`hw_extensions/exp_lut/sw/exp_lut.c`** (Exp LUT driver).  
  - Include: `-I litex_port/common -I hw_extensions/exp_lut/sw`.

- **GEMV only**  
  - Compile/link: same common sources + `litex_port/accel_gemv/main_gemv.c`, **`hw_extensions/gemv/sw/gemv.c`** (GEMV driver).  
  - Include: `-I litex_port/common -I hw_extensions/gemv/sw`.

- **DOT8 + LUT**  
  - Compile/link: same common sources + `litex_port/accel_dot8_lut/main_dot8_lut.c`, **`hw_extensions/dot8/sw/dot8.c`**, **`hw_extensions/exp_lut/sw/exp_lut.c`**.  
  - Include: `-I litex_port/common -I hw_extensions/dot8/sw -I hw_extensions/exp_lut/sw`.

- **DOT8 + LUT + GEMV (all)**  
  - Compile/link: same common sources + `litex_port/accel_all/main_all.c`, **`hw_extensions/dot8/sw/dot8.c`**, **`hw_extensions/exp_lut/sw/exp_lut.c`**, **`hw_extensions/gemv/sw/gemv.c`**.  
  - Include: `-I litex_port/common -I hw_extensions/dot8/sw -I hw_extensions/exp_lut/sw -I hw_extensions/gemv/sw`.

#### Run order and benchmarking

1. **Run baseline first** on the FPGA (e.g. build with `baseline/main_baseline.c`). Capture UART output; note the `MODE: BASELINE` banner and all `Sample i: pred=X exp=Y` lines.
2. **Run accelerator self-tests** (`test_dot8`, `test_lut`, `test_gemv`) as in §10 so that each block is known good.
3. **Build and run each accelerated mode** (DOT8, LUT, GEMV, DOT8+LUT, all). Each firmware prints a single banner (`MODE: DOT8`, `MODE: LUT`, etc.) so logs are self-identifying.
4. **Confirm correctness:** Accelerated outputs must match baseline: same `ENC_CKSUM=0xXXXXXXXX` per sample and same `pred`/`exp`. Only then compare performance.
5. **Then** measure performance (e.g. cycle counts) for baseline vs each accelerated variant.

#### Directory layout (litex_port)

- **`common/`** — Shared algorithm and support: `tinyformer.c/h`, `demo_samples.c/h`, `demo_classifier.c/h`, `demo_runner.c/h`, `uart_litex.c/h`, `trained_weights.c/h`. No duplication of TinyFormer logic.
- **`baseline/`** — `main_baseline.c`; no macros.
- **`accel_dot8/`**, **`accel_lut/`**, **`accel_gemv/`**, **`accel_dot8_lut/`**, **`accel_all/`** — Each has a `main_*.c` that prints the correct banner and calls the same `demo_run()` from common.

## Next Steps

Suggested next engineering steps:

- **UART integration**:  
  Replace the body of `uart_write_char` in `litex_port/main.c` with real LiteX UART MMIO operations so that the checksum is visible on the serial console.

- **Load real weights**:  
  Replace the placeholder zero-initialized weight and bias arrays in `litex_port/tinyformer.c` with trained, quantized int8 parameters exported from your training pipeline.

- **Add cycle counting**:  
  Instrument performance by reading the RISC-V cycle counter (`rdcycle`) before and after `tinyformer_encode` to measure latency on VexRiscv.

- **Hardware acceleration**:  
  Identify the critical matmul and attention loops in `tinyformer.c` and consider offloading them to FPGA accelerators or tightly coupled custom instructions, while preserving the same C API.

- **Extended testing**:  
  Add additional test cases and golden-reference comparisons (e.g., host-side Python or C reference) to validate the TinyFormer outputs across different inputs and weight configurations.

## Training + Weight Export

To use trained TinyFormer weights with the C inference kernel in `litex_port/`:

- **Training checkpoint**:  
  Train your TinyFormer encoder (S=16, D=32, FFN=64, 1 head) in PyTorch and save a `state_dict` containing at least the following keys:
  - `W_q`, `W_k`, `W_v`, `W_o` with shape `[32, 32]`
  - `W_ff1` with shape `[64, 32]` or `[32, 64]`
  - `W_ff2` with shape `[32, 64]` or `[64, 32]`
  - `b_q`, `b_k`, `b_v`, `b_o` with shape `[32]`
  - `b_ff1` with shape `[64]`
  - `b_ff2` with shape `[32]`

- **Export to C weights**:  
  From the repository root (`TinyML_algo/`), run:

  ```bash
  python3 tools/export_weights.py \
      --checkpoint path/to/state_dict.pt \
      --output-dir litex_port
  ```

  This generates:

  - `litex_port/trained_weights.h`
  - `litex_port/trained_weights.c`

  containing quantized `int8_t` weights and biases that match the layout expected by `litex_port/tinyformer.c`.

- **Enabling trained weights in C**:  
  The TinyFormer implementation supports a compile-time switch:

  ```c
  #define USE_TRAINED_WEIGHTS 1
  ```

  When `USE_TRAINED_WEIGHTS` is set to `1` at compile time (e.g. via compiler flags or a config header), `tinyformer.c` includes `trained_weights.h` and uses the exported arrays instead of the built-in zero-initialized placeholders. When it is `0` (default), the original placeholder weights are used.

## UCI HAR End-to-End Demo

This repository includes an end-to-end pipeline that trains a TinyFormer-based classifier on the UCI HAR dataset (using the raw inertial signals) and exports both:
- Quantized TinyFormer encoder weights for the C implementation in `litex_port/tinyformer.c`, and
- A small set of preprocessed demo samples that can be run on an FPGA target (VexRiscv + LiteX).

### Steps to run the full pipeline

From the repository root (`TinyML_algo/`), run:

```bash
python3 training/download_uci_har.py
python3 training/preprocess_uci_har.py
python3 training/train_tinyformer_uci_har.py
python3 training/export_and_make_fpga_demo.py
```

- `download_uci_har.py` downloads and extracts the UCI HAR dataset into `data/uci_har/`.
- `preprocess_uci_har.py` loads the raw inertial signals (6 channels × 128 timesteps), downsamples to 16 timesteps using average pooling, constructs 32-dimensional feature vectors per timestep, normalizes features using train mean/std, and saves `data/uci_har_processed.npz`.
- `train_tinyformer_uci_har.py` trains a TinyFormer encoder + classifier head (S=16, D=32, FFN=64, 1 head, 6 classes), prints train/test accuracy, and saves:
  - `artifacts/state_dict.pt` (TinyFormer encoder weights with keys `W_q`, `W_k`, `W_v`, `W_o`, `W_ff1`, `W_ff2`, `b_q`, `b_k`, `b_v`, `b_o`, `b_ff1`, `b_ff2`)
  - `artifacts/classifier.npz` (classifier head weights `W_cls[6,32]`, `b_cls[6]`).
- `export_and_make_fpga_demo.py`:
  - Runs `tools/export_weights.py` on `artifacts/state_dict.pt` to create `litex_port/trained_weights.c/h`.
  - Selects a small set of test samples, quantizes them to int8, and writes `litex_port/demo_samples.c/h`.
  - Quantizes the classifier head weights and writes `litex_port/demo_classifier.c/h`.

### What’s in this repo

This repository is self-contained and includes:

- **Raw dataset**: a copy of the UCI HAR Dataset under `data/uci_har_raw/`:
  - `data/uci_har_raw/UCI_HAR_Dataset.zip`
  - `data/uci_har_raw/UCI HAR Dataset/` (original folder structure from UCI, including inertial signal files).
- **Processed dataset**: TinyFormer-ready tensors under `data/uci_har_processed/`:
  - `data/uci_har_processed/uci_har_processed.npz` containing normalized `X_train`, `X_test` (shape `[N, 16, 32]`) and labels `y_train`, `y_test`.
- **Trained artifacts**: under `artifacts/`:
  - `artifacts/state_dict.pt` – TinyFormer encoder weights (`W_q`, `W_k`, `W_v`, `W_o`, `W_ff1`, `W_ff2`, and corresponding biases) ready for export.
  - `artifacts/classifier.npz` – classifier head weights (`W_cls[6,32]`, `b_cls[6]`).
- **FPGA-ready C exports**: under `litex_port/`:
  - `trained_weights.c/h` – quantized int8 TinyFormer encoder weights matching `tinyformer.c`.
  - `demo_samples.c/h` – a small set of test samples quantized to int8 with ground-truth labels.
  - `demo_classifier.c/h` – quantized classifier head weights/biases.

### Running the FPGA demo

On the LiteX/VexRiscv target (e.g., Nexys 4 DDR):

1. **Build firmware**  
   Include the following files in your LiteX bare-metal build:
   - `litex_port/tinyformer.c`, `litex_port/tinyformer.h`
   - `litex_port/main.c` (checksum demo) or `litex_port/demo_main.c` (UCI HAR classification demo)
   - `litex_port/trained_weights.c`, `litex_port/trained_weights.h`
   - `litex_port/demo_samples.c`, `litex_port/demo_samples.h`
   - `litex_port/demo_classifier.c`, `litex_port/demo_classifier.h`

   Compile with:

   ```bash
   -DUSE_TRAINED_WEIGHTS=1
   ```

   so that `tinyformer.c` uses the trained weights exported by the Python tooling.

2. **UART wiring**  
   Implement `uart_write_char` in `main.c` or `demo_main.c` to write to the LiteX UART MMIO registers. The helper functions `uart_write_string` and the demo printing logic will then send checksums or predicted labels to the serial console.

3. **Run via litex_term**  
   After building the firmware ELF, run it on the FPGA using:

   ```bash
   litex_term --kernel firmware.elf
   ```

   - `main.c` will print a checksum of a single TinyFormer encoder pass.
   - `demo_main.c` will iterate over the generated demo samples, run the TinyFormer encoder + classifier head, and print predicted vs expected activity labels for quick on-board validation.

### Model Status: Pre-Trained (Ready for FPGA)

- The TinyFormer encoder and classifier have been **trained on the UCI HAR dataset** using the scripts in `training/`.
- The exported, FPGA-ready artifacts are **already committed**:
  - `litex_port/trained_weights.c/h`
  - `litex_port/demo_samples.c/h`
  - `litex_port/demo_classifier.c/h`
- This means your friend can clone the repo, build the LiteX firmware with these files, and immediately run the UCI HAR demo on the FPGA without retraining.

### FPGA Quickstart — Nexys 4 DDR + VexRiscv + LiteX

1. **Build LiteX SoC**  
   - Use LiteX to build a VexRiscv-based SoC for the Nexys 4 DDR board with DDR2 enabled (as in the standard LiteX examples for this board).

2. **Build firmware including these sources**  
   Add the following C sources to your LiteX firmware build:
   - `litex_port/tinyformer.c`
   - `litex_port/demo_main.c`
   - `litex_port/trained_weights.c`
   - `litex_port/demo_samples.c`
   - `litex_port/demo_classifier.c`

   Make sure the corresponding headers are in the include path:
   - `litex_port/tinyformer.h`
   - `litex_port/demo_samples.h`
   - `litex_port/demo_classifier.h`
   - `litex_port/trained_weights.h`

   Compile with:

   ```bash
   -DUSE_TRAINED_WEIGHTS=1
   ```

   so that `tinyformer.c` uses the trained weights from `trained_weights.c` instead of the placeholder zeros.

3. **Wire UART MMIO**  
   - In `demo_main.c`, implement `uart_write_char` using the LiteX-generated CSR headers (e.g. `build/<target>/software/include/generated/csr.h`):
     - Poll `uart_txfull` until space is available.
     - Write the character to `uart_rxtx`.
   - The helper functions `uart_write_string` and the demo code will then print to the serial console.

4. **Run firmware with litex_term**  
   - After building the firmware ELF (e.g. `firmware.elf`), run:

   ```bash
   litex_term --kernel firmware.elf
   ```

   - `demo_main.c` will:
     - Iterate over the committed demo samples.
     - Run the TinyFormer encoder and classifier on each sample.
     - Print lines of the form:

       ```text
       Sample 0: pred=<predicted_class> exp=<expected_class>
       ```

     where `pred` is the predicted activity class (0..5) and `exp` is the ground-truth label.

### Re-training (Optional)

If you want to retrain the model (e.g. to tweak hyperparameters or add data), you can rerun the training pipeline:

```bash
python3 training/download_uci_har.py              # only needed once
python3 training/preprocess_uci_har.py
python3 training/train_tinyformer_uci_har.py
python3 training/export_and_make_fpga_demo.py
```

This will:
- Regenerate `data/uci_har_processed/uci_har_processed.npz`.
- Retrain the TinyFormer encoder + classifier and update:
  - `artifacts/state_dict.pt`
  - `artifacts/classifier.npz`
- Re-export updated FPGA artifacts:
  - `litex_port/trained_weights.c/h`
  - `litex_port/demo_samples.c/h`
  - `litex_port/demo_classifier.c/h`

Rebuild your LiteX firmware after retraining to pick up the new weights and demo samples.



