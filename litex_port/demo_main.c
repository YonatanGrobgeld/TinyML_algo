// Demo main for TinyFormer + UCI HAR on LiteX / VexRiscv.
//
// This program iterates over a small set of pre-quantized demo samples
// (generated by training/export_and_make_fpga_demo.py), runs the TinyFormer
// encoder, mean-pools over the sequence, applies a simple linear classifier
// head, and reports predicted vs expected labels.
//
// UART printing is stubbed; replace uart_write_char() with real LiteX UART
// MMIO writes to use this on hardware.

#include <stdint.h>
#include "tinyformer.h"
#include "demo_samples.h"
#include "demo_classifier.h"

// UART stubs (same style as main.c)
static void uart_write_char(char c)
{
    (void)c;
    // Implement: wait for TX ready, then store c into UART TX register.
}

static void uart_write_string(const char *s)
{
    while (*s != '\0') {
        uart_write_char(*s);
        s++;
    }
}

static void uart_write_uint32(uint32_t value)
{
    char buf[11];
    int i = 10;
    buf[i--] = '\0';
    if (value == 0) {
        buf[i] = '0';
        uart_write_string(&buf[i]);
        return;
    }
    while (value > 0 && i >= 0) {
        buf[i--] = (char)('0' + (value % 10u));
        value /= 10u;
    }
    uart_write_string(&buf[i + 1]);
}

// Saturation helper (same semantics as tinyformer.c)
static int8_t saturate_int32_to_int8(int32_t x)
{
    if (x > 127) return 127;
    if (x < -128) return -128;
    return (int8_t)x;
}

// Mean-pool over sequence dimension: pooled[d] = mean_s tokens[s][d]
static void mean_pool_tokens(
    const int8_t tokens[TINYFORMER_S][TINYFORMER_D],
    int8_t       pooled[TINYFORMER_D])
{
    for (int d = 0; d < TINYFORMER_D; ++d) {
        int32_t acc = 0;
        for (int s = 0; s < TINYFORMER_S; ++s) {
            acc += (int32_t)tokens[s][d];
        }
        // Divide by S with rounding: (acc + S/2) / S
        acc = (acc + (TINYFORMER_S / 2)) / TINYFORMER_S;
        pooled[d] = saturate_int32_to_int8(acc);
    }
}

// Classifier head: logits[c] = sum_d cls_W[c][d] * pooled[d] + cls_b[c]
static void classifier_forward(
    const int8_t pooled[TINYFORMER_D],
    int32_t      logits[DEMO_NUM_CLASSES])
{
    for (int c = 0; c < DEMO_NUM_CLASSES; ++c) {
        int32_t acc = (int32_t)cls_b[c];
        const int8_t *w_row = &cls_W[c][0];
        for (int d = 0; d < TINYFORMER_D; ++d) {
            acc += (int32_t)w_row[d] * (int32_t)pooled[d];
        }
        logits[c] = acc;
    }
}

int main(void)
{
    uart_write_string("TinyFormer UCI HAR demo starting\r\n");

    for (uint32_t i = 0; i < (uint32_t)DEMO_NUM_SAMPLES; ++i) {
        static int8_t encoded[TINYFORMER_S][TINYFORMER_D];
        static int8_t pooled[TINYFORMER_D];
        int32_t logits[DEMO_NUM_CLASSES];

        // Run encoder
        tinyformer_encode(demo_inputs[i], encoded);

        // Mean-pool over time
        mean_pool_tokens(encoded, pooled);

        // Classifier
        classifier_forward(pooled, logits);

        // Argmax
        int32_t best_val = logits[0];
        uint32_t best_idx = 0;
        for (uint32_t c = 1; c < (uint32_t)DEMO_NUM_CLASSES; ++c) {
            if (logits[c] > best_val) {
                best_val = logits[c];
                best_idx = c;
            }
        }

        // Print result line: sample i, predicted, expected
        uart_write_string("Sample ");
        uart_write_uint32(i);
        uart_write_string(": pred=");
        uart_write_uint32(best_idx);
        uart_write_string(" exp=");
        uart_write_uint32((uint32_t)demo_labels[i]);
        uart_write_string("\r\n");
    }

    while (1) {
        // Idle
    }

    return 0;
}

